[БЕЗ_ЗВУКА] В этом видео мы познакомимся с некоторыми простыми конструкциями языка Python и начнем привыкать к его синтаксису. Итак, давайте разберемся с условным оператором. Точно так же, как и во многих других языках программирования, здесь можно написать что-нибудь в духе… Давайте заведем какую-то переменную, напишем, пусть она равна true, и напишем if x print ok Если мы хотим рассмотреть другой случай, то пишем else: и что-нибудь еще. Проверяем. Да, все хорошо. Если сейчас поменяем на false, всё работает так, как нужно. Теперь обратите внимание: если во многих других языках программирования, когда мы пишем какую-то такую конструкцию, дальше тело следует в каких-нибудь скобочках, то в Python для этого используются отступы. Отступы должны быть единообразными. Вот я здесь просто отступил на Tab, а если мы продолжаем тело, то нужно писать опять-таки тоже с отступом. Давайте еще что-нибудь напишем и посмотрим, что всё хорошо, всё работает. Ok. Теперь давайте разберемся с чем-нибудь еще. Ну, например, с циклами. Циклы встречаются, наверное, почти что в каждой программе. И давайте напишем простой цикл, в котором будем выводить числа от 1 до 10. For i in range (10), и опять же так же с отступом пишем print i. Давайте посмотрим, что получится. Ну смотрите. Вывелись числа 0, 1... 9. То есть такая конструкция приводит к тому, что мы получаем все числа от 0 до 9 включая, то есть 10 не входит в этот интервал. При этом мы могли бы написать, ну, например, вот таким вот образом, и задать первое число. Тогда бы мы получили бы число от 1 до 9, и обратите внимание: когда мы делаем print, сразу же происходит перевод на следующую строку. Если мы хотим от этого избавиться, мы можем поставить здесь запятую, и тогда все это будет выведено через пробелы. Теперь давайте чуть подробнее изучим, что же такое range. Давайте просто сделаем print range от 2 до 5. Вот мы видим, что это просто какой-то список. И отсюда у нас возникает мысль, что может быть в Python можно писать каким-нибудь таким образом: for i in, давайте прям напишем список, print i. В самом деле, так и есть: оказывается, в Python циклы у нас устроены не таким образом, что мы обязательно в каком-то диапазоне значений пробегаемся, а мы просто пробегаемся по какому-нибудь контейнеру с элементами. Ну, например, по списку. То есть если мы возьмем и посмотрим type от range, то мы сразу же обнаружим, что это просто список. Сразу расскажу еще одну интересную вещь. Мы могли бы написать не range, а xrange, ну и то же самое, и увидеть, что результат абсолютно тот же. Возникает естественный вопрос — а зачем же нужно два способа добиться одного и того же результата? На самом деле результат не совсем один и тот же. Оказывается, если мы посмотрим тип xrange, то мы увидим, что xrange имеет тип xrange. Ну хорошо. Яснее нам не стало, но мы поняли, что это не список. Давайте еще напечатаем: xrange. [БЕЗ_ЗВУКА] Здесь мы видим чуть больше конкретики, но по-прежнему остается некоторая загадка. Оказывается, xrange — это естественный пример генератора. А генератор не представляет из себя сразу готовый список различных значений, а генерирует их прямо на ходу. То есть у вас в памяти не хранится длинный список, как если вы напишите range и какое-то большое число. Например, так. Если вы пишите for i in range от чего-то большого, то лучше всё же написать xrange. Давайте чуть подробнее познакомимся с генераторами, но для этого сначала мы изучим вещь, которая называется list comprehension. Оказывается, в Python очень многие вещи можно писать буквально в одну строчку. Давайте попробуем вывести числа от 1 до 10 в массиве и возведя их в квадрат. Можно просто взять написать print, квадратные скобочки, и в квадратных скобочках мы прямо пишем — x в квадрате for x in range 1 до 10 включительно, наверное, давайте выведем, так что (1, 11). Нажимаем и видим — да, действительно, результат. Теперь давайте попробуем оставить из них только четные. Для этого достаточно дописать if x % 2 = 0. Дописываем, пожалуйста — остались только четные из них. Теперь давайте не будем это выводить на печать, а просто создадим объект, который будет равен вот этому всему. Сделали, теперь посмотрим тип. [БЕЗ_ЗВУКА] Как мы видим, тип этого объекта — список, и здесь у нас возникает опять же вопрос — а как бы нам сделать не список, а генератор? То есть не хранить сразу все эти значения в памяти. Оказывается, для этого достаточно заменить квадратные скобочки на круглые. Давайте посмотрим, что получилось. Вот, действительно, тип — генератор. Таким образом, range отличается от xrange ровно тем, чем в этом выражении отличаются квадратные скобочки от круглых. Давайте теперь выясним, что у нас есть еще какие-то способы написать цикл. Например, давайте скажем, что x = true, а while x, заведем какую-нибудь переменную, будем внутри цикла ее инкрементировать, и if s > 10, сделаем break, то есть завершим цикл. И давайте всё это будем печатать, print s. Оказывается, такой цикл тоже можно делать. В цикле можно использовать break, можно использовать continue, которое приводит сразу же к переходу на следующею итерацию. Давайте напишем так: if s % 2 = = 0, сделаем continue и посмотрим, как это отразится на выдаче. [БЕЗ_ЗВУКА] Мы видим, что вроде бы никак существенно не отразилось. Давайте попробуем понять, почему. [БЕЗ_ЗВУКА] Для этого попробую переставить в другое место. [БЕЗ_ЗВУКА] И вот видите, мы получили нечаянно бесконечный цикл. Потому что мы просто проверяем, что остаток от деления на 2 равен 0 до того, как изменяем переменную s, и это условие у нас выполняется постоянно, и мы всё время делаем continue. Давайте прервем исполнение этого кода, вернем обратно. [БЕЗ_ЗВУКА] И давайте, если это условие выполнилось, тоже что-нибудь напишем. Вот, смотрите. В этой ситуации мы получили следующий эффект: мы просто делаем переход на следующую итерацию, в случае если s четное, и ничего не печатаем. Почему же в первый раз у нас получилось не совсем так? Просто это выражение у нас было написано после print s, поэтому вывод действительно не отличался. Ну и давайте теперь познакомимся с функциями в Python. Допустим, нам нужно реализовать, ну например, свой range. Давайте напишем def myrange, пусть опять же будут две переменные a и b, от которых зависит результат. И также с отступом пишем return и здесь напишем list comprehension. x for x in... Ах, нет, тогда нам придется использовать range. Наверное, это не очень хорошо. Давайте тогда просто создадим список и напишем for... Или даже так: while s не равно b, будем добавлять список с помощью метода append(s) и увеличивать s на единичку. Ну и давайте посмотрим, будет ли это все работать и как: print myrange. Ну вроде похоже на правду. Конечно, можно было бы еще подумать о каких-то особых ситуациях, когда мы будем давать не совсем подходящие числа на вход, но это не является нашей целью сейчас. Сейчас наша цель — просто познакомиться с синтаксисом. Синтаксис функций мы уже увидели. Ну и давайте напоследок я расскажу еще об одной интересной вещи. Оказывается, нам не обязательно писать что-то в духе x ** 2 for x in range(10), если мы хотим получить квадраты первых десяти чисел. Оказывается, тот же результат можно получить с помощью функции map. Функция map просто применяет некоторую функцию к контейнеру. Давайте опять напишем print map, здесь напишем range(10). Но какую функцию мы будем применять? Нам хочется возводить в квадрат. Давайте сразу определим функцию возведения в квадрат [ЗВУК] и ее и подставим в map. Ну да, так работает. Но на самом деле есть еще одна удобная вещь: можно функции определять прямо на ходу с помощью так называемых лямбда-выражений. Ну например, мы можем написать map, точно так же написать range(10), а в качестве первого аргумента напишем следующую вещь: lambda, дальше пишем переменную, x, дальше двоеточие и пишем то, что нужно возвращать, x в квадрате. Посмотрим на результат. Да, все так, как нужно. Если нам нужно ввести функцию от нескольких переменных, то мы можем перечислить их здесь через запятую и использовать их каким-нибудь вот таким вот образом. Ну а здесь, конечно, этот код не заработает, потому что у нас подается на вход одна переменная. Итак, мы познакомились с основными конструкциями языка Python. В следующем видео вы узнаете о том, как читать из файла и как записывать в файл.

На этом видео мы начнем говорить о работе с файлами в Python. Часто для анализа нам требуется использовать данные, хранящиеся в некотором внешнем файле, это может быть электронная таблица, простой текстовый документ, html-документ — любой доступный для хранения данных формат. А для этого Python предоставляет нам целый ряд разнообразных инструментов. Мы с вами начнем с простого и изучим встроенную функцию open. Если вы встречаетесь с некоторой функцией в первый раз, то полезно почитать ее Docstring. Это делается с помощью вопросительного знака. Набираем вопросительный знак и имя функции. Внизу экрана открывается Docstring. Мы можем увидеть, что функция принимает три аргумента: это name, mode и buffering. Нас будут интересовать первые два из них. Аргумент name отвечает за название файла, который мы хотим открыть. Если файл лежит в той же директории, что и Ipython, то можно просто написать его имя. Если же он в другой директории, то придется прописать путь. mode отвечает за то, каким образом мы хотим работать с файлом. Если мы не планируем делать никаких изменений, а например просто хотим прочитать содержимое файла или прочитать его в какой-то контейнер, то нам подойдет режим для чтения. В этом случае мы не сможем изменять сам файл, но тем не менее мы сможем его читать. Если мы хотим перезаписать существующий файл или записать новый, то нам нужен режим для записи. Если же мы хотим взять существующий файл и как-то его модифицировать, например добавить какие-то строчки в его конец, то нам подойдет режим append — режим для добавления данных в конец. Итак, мы с вами будем решать довольно простую задачу: мы возьмем файл, откроем его и выведем его содержимое на экран. Тогда нам подойдет режим для чтения. Итак, давайте зададим новый объект, назовем его file_obj, и с помощью функции open откроем файл. [БЕЗ_ЗВУКА] Далее, если мы хотим открывать файл в режиме для чтения, то нам необязательно указывать mode, потому что по умолчанию файл открывается в режиме для чтения. Но давайте мы его укажем, для того чтобы это было явно видно. Итак, мы создали наш объект, давайте теперь посмотрим, какой у него тип. Это делается с помощью команды type. Итак, мы видим, что тип нашего объекта — действительно file. Теперь давайте выведем его на экран. Это можно сделать с помощью функции read. [БЕЗ_ЗВУКА] Мы видим, что наш файл состоит из трех строк, все эти строчки на русском языке. Часто нам бывает удобно считывать файл не полностью, а например, считывать его по строкам. В частности, если у нас большой файл, нам бывает интересно просто почитать, как он начинается, прочесть несколько первых строк, а весь текст файла нам не нужен. В этом случае бывает удобно воспользоваться функцией readline. Для начала нам снова придется открыть файл для чтения. [БЕЗ_ЗВУКА] [БЕЗ_ЗВУКА] [БЕЗ_ЗВУКА] А далее давайте вызовем функцию readline. [БЕЗ_ЗВУКА] И видим, что у нас вывелась на экран только первая строка. А повторный вывоз данной функций приведет к печати следующей строки. Давайте посмотрим. [БЕЗ_ЗВУКА] Если продолжать процедуру, то мы таким образом можем дойти до конца файла. Вот вывод пустой строки на экран обозначает конец файла. На самом деле, для того чтобы обращаться к файлу построчно, нам совсем необязательно пользоваться такими функциями, как read и readline. Мы можем обращаться с файлом как с обычным генератором. Давайте посмотрим, как это выглядит. Снова откроем файл, [БЕЗ_ЗВУКА] а дальше просто с помощью цикла for давайте этот файл обойдем и выведем на экран каждую его строчку. [БЕЗ_ЗВУКА] [БЕЗ_ЗВУКА] Обращаю внимание, что мы используем здесь снова функцию, это функция strip. Она помогает отрезать нам от конца каждой строки пробельные символы. Это могут быть пробелы, знаки табуляции, а также знаки переноса строки. Итак, вызываем функцию и видим, что наш файл также напечатался построчно. Часто мы хотим работать со строчками файла как с массивом. Что имеется в виду? У нас есть файл, который состоит из нескольких строк, и мы хотим создать список, каждый элемент которого соответствует отдельной строке файла. Часто это бывает удобно. Это также можно сделать несколькими способами. Первый способ, самый простой — изменить тип объекта file на список и просто работать с ним как со списком. Давайте это сделаем. Создадим объект data_list — список, и просто с помощью команды list сделаем наш файл объектом типа «список». Снова открываем файл для чтения. [БЕЗ_ЗВУКА] И получаем наш список. Теперь давайте выведем содержимое списка на экран, чтобы убедиться, что каждый элемент соответствует отдельной строчке. [БЕЗ_ЗВУКА] [БЕЗ_ЗВУКА] [БЕЗ_ЗВУКА] [БЕЗ_ЗВУКА] Итак, видим, что результат снова нас удовлетворяет — мы построчно вывели файл на экран. Второй способ — это использование функции readlines, она возвращает список строк нашего файла. [БЕЗ_ЗВУКА] Уже привычным нам способом открываем файл, [БЕЗ_ЗВУКА] и далее, с помощью функции readlines создаем новый список. [БЕЗ_ЗВУКА] [БЕЗ_ЗВУКА] Итак, список готов, теперь снова давайте его напечатаем. [БЕЗ_ЗВУКА] [БЕЗ_ЗВУКА] Итак, готово. Соответственно, теперь вы можете выбирать тот способ, который вам больше нравится: использование функции readlines или просто работа с файлом как со списком. Когда мы закончили работу с файлом, файл нужно закрыть. Это делается с помощью команды close. Это полезно сразу по нескольким причинам. Первая причина — мы освобождаем ресурсы, которые используются системой на чтение и поддержку нашего файла. Вторая причина — это так называемая безопасная работа с файлом. После того как мы файл закрыли, мы уже не можем его читать, не можем вносить в него изменения. Таким образом, наш файл в какой-то степени защищен от каких-то незапланированных действий или ошибок. Давайте посмотрим, как это работает. Если мы сначала открыли файл, например открываем его снова для чтения. Возьмем тот же самый файл. Дальше мы вызвали функцию, которая его закрывает — функция close. [БЕЗ_ЗВУКА] И дальше, например, давайте попробуем его прочесть, после того как мы его закрыли. Это должно привести к ошибке, потому что мы пытаемся прочитать уже закрытый файл. И действительно — мы видим, что операция такая невозможна, потому что мы пытаемся прочитать закрытый файл. Итак, мы с вами уже научились читать файл и делать это несколькими способами. На самом деле, все это время мы работали с файлом в кодировке UTF-8, это можно было понять из названия. В жизни это не всегда так, и часто нам приходится работать с данными в разных кодировках. Давайте теперь попробуем открыть файл в кодировке KOI8-R — это русскоязычная кириллица. Для начала попробуем поступить аналогичным образом. Используем функцию open, создаем объект file и пытаемся прочитать его, после чего вывести его на экран. [БЕЗ_ЗВУКА] Теперь вызываем метод read. [БЕЗ_ЗВУКА] И видим, что наш файл выглядит не совсем так, как нам хотелось. Давайте добавим функцию [НЕРАЗБОРЧИВО] и убедимся в этом. Вот видите, появились какие-то не очень симпатичные символы. Это говорит о том, что у нас есть проблема с этой кодировкой. Для того чтобы напечатать этот файл красиво, нужно каким-то образом указать, что мы используем кодировку UTF-8. Но на самом деле, сделать это можно разными способами. Один из самых простых — это использовать библиотеку Codeos. Давайте на нее посмотрим. [БЕЗ_ЗВУКА] Для начала ее нужно импортировать. Это делается с помощью ключевого слова import. [БЕЗ_ЗВУКА] А теперь давайте читать файл. На самом деле, библиотека Codeos предоставляет нам похожую функцию open, у нее схожий синтаксис, только нам нужно указать еще дополнительные параметры, например кодировку. Вот давайте это сделаем. Снова создадим объект file, назовем его file_obj. И теперь уже с помощью функции open из модуля Codeos будем его читать. Передаем туда название файла. И теперь давайте добавим новый параметр encoding, или кодировка. [БЕЗ_ЗВУКА] Так, файл мы прочли, теперь давайте выведем его на экран, ожидая, что теперь у нас не будет проблем с выводом. [БЕЗ_ЗВУКА] Итак, мы видим, что теперь файл выводится корректно. Это происходит потому, что мы открыли его в правильной кодировке. На этом мы заканчиваем знакомство с чтением данных, а в следующем видео мы также будем говорить про работу с файлами, но уже будем учиться файлы записывать.

В этом видео мы продолжим говорить о работе с файлами в Python. В прошлый раз мы научились читать данные с файлов, теперь давайте учиться их в файл записывать. Это часто бывает полезно, особенно если хочется сохранить результаты вашей работы для дальнейшего анализа. Итак, мы уже знаем, что открывать файлы можно с помощью функции open из стандартной библиотеки или из библиотеки codecs. Давайте продолжим работать со встроенной функцией и откроем файл для записи. В этот раз мы будем решать следующую задачу: создадим несколько текстовых строк и запишем их в файл. Для начала снова открываем файл, в этот раз для записи. [ЗВУК] Давайте назовем его как-нибудь просто, file_to_write_in, «файл для записи», и указываем режим w, режим writing. Так, дальше нам нужно создать строчку, которую мы в файл будем записывать. Давайте просто напишем «строка для записи в файл». В конец строки не забываем добавить символ переноса строки. Он нужен, для того чтобы, в случае если мы записываем в файл сразу несколько строк, они бы не склеились в одну, а шли одна за другой. Так читать гораздо приятнее. Дальше с помощью функции write записываем эту строчку в наш файл [ЗВУК] и дальше не забываем закрыть файл. Давайте это запустим. Так, забыли скобочки. Теперь запустим еще раз. И теперь давайте посмотрим, как выглядит наш файл. Для этого можно использовать команду bash cat. [ЗВУК] Видим, что наш файл выглядит ровно так, как мы с вами и хотели. Та самая строчка, которую мы в него записывали, выведена на экран. Теперь давайте повторим процесс. Допустим, нам хочется записать еще одну строчку в этот файл. Казалось бы, нужно действовать аналогичным образом. Снова открыть файл для записи, записать строчку и вывести файл на экран. Давайте попробуем. Открываем файл, [ЗВУК] Давайте теперь создадим какую-нибудь новую строчку. Давайте напишем «вторая строка для записи в файл». [ЗВУК] Снова не забываем про символ переноса строки. Далее вызываем у файла метод write, записываем строчку [ЗВУК] и закрываем наш файл. Так, поправим имя функции и сделаем это еще раз. Итак, давайте выведем файл на экран и посмотрим, как он выглядит. [ЗВУК] Что мы видим? Наша первая строка исчезла, зато в файле появилась вторая строка. Это произошло из-за того, что мы перезаписали наш старый файл новым. Так происходит, когда мы работаем с файлами в режиме write. Если файл уже существует в данной директории, то он будет перезаписан новым файлом, а если бы файла с таким названием еще не было, то мы бы действительно создали новый файл, как в первый раз. Теперь давайте все-таки сделаем правильно. Мы с вами хотим добавить строчку в конец существующего файла, а не переписать его заново. Для этого нам просто нужно использовать другой режим. Это режим append, или режим добавления. Так, давайте снова откроем файл, [ЗВУК] только теперь не забудем указать правильный режим. Создадим новую строчку и напишем «третья строка для записи в файл». [ЗВУК] И с помощью уже знакомой нам функции write запишем эту строчку в файл. [ЗВУК] [ЗВУК] Так, теперь давайте посмотрим, что у нас получилось. Мы ожидаем увидеть две строки. Итак, действительно, в нашем файле появилась вторая и третья строка. На самом деле, часто мы хотим записать сразу много строк в файл. У нас может быть целый список строк для записи. Мы можем делать это разными способами, но самое простое — это просто в цикле записать все эти строчки с помощью функции write. Но можно поступить по-другому. Для этого существует специальная функция writelines, которая принимает в качестве аргумента список строк для записи в файл. Давайте продемонстрируем ее работу. Для начала нам с вами нужно создать этот список строк. Давайте сделаем что-нибудь простое. Допустим, запишем в файл числа от 1 до 10. Для этого сначала создаем массив этих чисел, назовем его digits и сделаем это с помощью функции range. Давайте выведем его на экран. Итак, мы видим, что это простые числа. Теперь нужно их записать. Но тут есть два нюанса. Во-первых, в файл мы можем записывать только строчки, поэтому сначала нам нужно изменить тип нашего массива и сделать его массивом строк. Второй нюанс следующий: если мы запишем эти строки как есть, то они у нас при записи склеятся в одно значение, потому что у нас нет символов перевода строки. Поэтому перед записью нам с вами нужно не забыть эти символы добавить в конец каждой строки. Так. Теперь снова открываем файл для записи. Давайте сделаем это немножечко по-другому: будем использовать ключевое слово with. Это довольно удобно, потому что в этом случае нам не нужно беспокоиться о закрытии файла. Мы можем быть уверены, что при выходе из блока with, файл будет закрыт. Итак, набираем это ключевое слово, дальше открываем файл для записи как обычно, с помощью функции open. Давайте запишем данные на этот раз в другой файл, назовем его «второй файл для записи». [ЗВУК] [ЗВУК] Дальше сразу же начинаем писать с помощью функции writelines. [ЗВУК] Не забываем, что ей нужно передать массив, но мы хотим с ним сделать дополнительные действия. Для начала давайте добавим символы перевода строки, это символ \n. А теперь с помощью функции map давайте изменим тип нашего массива. [ЗВУК] Вот так. Мы закончили, теперь можем запускать. Теперь давайте посмотрим, как выглядит наш файл. [ЗВУК] Вот так. Он ровно такой, как нам бы и хотелось, 10 строк по одному числу в каждой строчке. Итак, на этом мы с вами заканчиваем работу с файлами. Теперь вы умеете работать с файлами в различных кодировках, можете читать данные, можете их записывать. А в следующем видео мы начнем знакомство с библиотекой Pandas. Она также позволяет нам гибко работать с файлами, в частности, она позволяет нам работать с файлами в виде таблиц. Это довольно удобно для задач анализа данных.

[БЕЗ_ЗВУКА] В этом виде мы начнем знакомство с библиотекой Pandas. Pandas — очень мощный инструмент для анализа данных в Python. Pandas позволяет нам работать с данными в виде таблиц. Это очень естественное представление данных в задачах анализа. Например, если мы решаем задачу классификации данных, то часто мы работаем с матрицей «объект-признак». В этом случае по строчкам у нас идут объекты, а по столбцам их признаки. Опять же, если мы решаем задачу построения рекомендательных систем, снова мы работаем с таблицами. Мы работаем с таблицей «user-item» или с матрицей предпочтений. Итак, переходим к нашей библиотеке. Сначала нам нужно ее импортировать. Делаем это с помощью команды import. [БЕЗ_ЗВУКА] Я использую стандартное сокращение pd, вы будете часто это встречать в коде. Итак, основной структурой данных, которая позволяет нам работать с таблицами, является Data Frame. Data Frame можно представлять себе как такую двумерную матрицу или как dict-like container для работы с Series. Series — это обычный одномерный iii массив. Он отличается от простого массива только тем, что в простом массиве у нас все элементы проиндексированы от 0 до размера массива минус 1, а тут у нас элементы могут иметь лейблы. То есть это могут быть, в принципе, произвольные имена. Итак, создадим нашу первую таблицу, или наш первый Data Frame. Сделаем мы это с помощью словаря. Пусть наш Data Frame состоит всего лишь из двух столбцов: первый столбец будет числами, второй столбец будет каким-нибудь повторяющимся символом. Теперь создаем наш словарь. [БЕЗ_ЗВУКА] [БЕЗ_ЗВУКА] Итак, мы сделали табличку, теперь давайте выведем ее на экран и посмотрим, как она выглядит. Итак, мы видим, что названия столбцов соответствуют нашим ключам в словаре и значения соответствуют тому, чем мы их заполнили. Довольно удобно. На самом деле такой способ создания Data Frame будет использоваться не так часто, потому что обычно мы хотим анализировать какие-то внешние данные, эти данные часто хранятся в виде файлов или и в виде наборов файлов, поэтому нам удобнее будет считывать эти данные в Data Frame и дальше работать с ними как с таблицами. Давайте попробуем такое сделать. Для этого есть функция read_csv. Она позволяет нам считывать данные с каким-то стандартным разделителем и далее работать с ними как с таблицей. Создадим новый объект и считаем в него специально заготовленный файл. [БЕЗ_ЗВУКА] В качестве первого аргумента передаем имя этого файла, [БЕЗ_ЗВУКА] дальше нам нужно указать, есть ли в нашем файле заголовки. В нашем файле они есть, они находятся в первой строчке, и дальше нужно написать, какой разделитель у нас используется. В данном случае мы используем табуляцию. Итак, мы считали наш файл в таблицу, давайте на нее посмотрим. [БЕЗ_ЗВУКА] Видим, что получилась небольшая табличка. Она состоит из шести строк и четырех столбцов. Наши столбцы имеют имена, они перед вами в верхней строчке, и строки опять проиндексированы. Кстати, чтобы обратиться к именам столбцов или чтобы их поменять, есть специальный атрибут, назвается columns. Таким образом можно к нему обратиться, через точку. И вот мы видим все наши имена столбцов. Также довольно полезный атрибут — shape, с помощью него можно посмотреть на размер нашей таблицы. Сейчас табличка маленькая, мы и так представляем себе ее размеры, а когда таблица довольно большая, то это полезно. [БЕЗ_ЗВУКА] Итак, мы научились создавать Data Frame, теперь давайте потренируемся их модифицировать. Мы можем удалять и добавлять строчки, удалять и добавлять столбцы. Давайте начнем с простого и добавим в конец нашего Data Frame новую строчку. Строчку будем добавлять в виде словаря. Это далеко не единственный способ добавления строки, но он довольно простой. Для начала давайте создадим такой словарь. Назовем его new_line, потому что он будет являться впоследствии новой линией в нашем Data Frame, в нашей таблице. Ну и давайте заполним какие-нибудь значения. Допустим, заполним имя, ну давайте еще заполним дату рождения, ну вот можно еще заполнить город. [БЕЗ_ЗВУКА] Итак, наш словарь готов, теперь с помощью команды append нужно его добавить к нашему Data Frame. Вызываем у фрейма метод append, в качестве первого аргумента передаем наш словарь, и еще указываем аргумент ignore_index = True, потому что нам не так важно, под каким индексом добавится наша новая строчка. Сделали команду, видим, что в конце Data Frame добавилась новая шестая строка с тем, что мы заполнили. Давайте еще раз выведем на печать наш Data Frame. Видим, что здесь этих изменений нет. Почему это произошло? Потому что команда append на самом деле работает не inplace, то есть она никак не изменяет наш исходный Data Frame. Она вносит нужные изменения и возвращает нам его копию. Если мы хотим, чтобы наш Data Frame изменился, то нужно немножечко модифицировать нашу команду. Опять же, как вариант, можно сделать вот так. Тогда, если мы снова выведем на печать наш Data Frame, то увидим, что он изменился. Действительно добавилась новая строчка. Теперь давайте добавим новые столбцы. Это делается довольно просто, потому что наш Data Frame можно представлять себе как такой словарь series. Если мы добавляем новый объект к словарю, то как мы делаем? Просто указываем значение нового ключа и добавляем объект. Вот давайте здесь поступим по аналогии. Итак, пишем его название и дальше более-менее случайно давайте его заполним. [БЕЗ_ЗВУКА] Так, готово. Выводим наш Data Frame на экран и видим, что добавился новый столбец. Так, с добавлением более-менее разобрались. Теперь давайте что-нибудь удалим. Сначала можно удалить некоторые строчки. Вот давайте последние две строки удалим. Для этого существует команда drop. Сначала указываем, какие именно объекты мы удаляем. Если мы удаляем строчки, то нам нужно указывать название индекса. То есть название этой оси. Ну вот смотрим: давайте удалим две последних строки, у них номера 5 и 6, указываем, что эти номера мы указываем по оси 0, и запускаем. Видим, что наш Data Frame стал на две строки короче. Но у drop есть такая же особенность, как и у функции append. Она тоже работает не inplace, поэтому если мы еще раз выведем на экран наш Data Frame, то мы обнаружим, что все строчки на месте. Чтобы это поправить, нужно в предыдущей команде добавить аргумент inplace=True, если мы действительно хотим удалить эти строчки из исходного Data Frame. Итак, запускаем и проверяем. Действительно, строчки удалились. Аналогично можно удалить столбцы. Здесь нам снова понадобится функция drop. Только в данном случае нам нужно будет обращаться уже не к индексам, а к именам наших столбцов. Давайте удалим тот столбец, который мы с вами недавно создали. Обращаемся к нему по имени, только обратиться нужно правильно, иначе ничего не получится, дальше указываем, что мы работаем с осью 1, ну и давайте тоже сделаем это сразу inplace. [БЕЗ_ЗВУКА] Так, готово. Выводим наш Data Frame на экран, и видим, что всё получилось: наш столбец пропал. Часто после того как мы проделываем какие-то манипуляции с Data Frame, например, чистим данные, добавляем новые столбцы, вычисляем какие-то новые значения, нам хочется сохранить результат в виде файла, чтобы в дальнейшем с ним работать. Pandas позволяет нам сделать этого с помощью простого метода. Он называется to_csv. Давайте запишем наш новый получившийся Data Frame в файл. Для этого вызываем эту функцию to_csv. Давайте теперь аккуратненько заполним ее аргументы. Для начала нужно написать название файла, в который мы хотим сохранить наш Data Frame. [БЕЗ_ЗВУКА] Давайте придумаем какое-нибудь простое название: updated_dataset. Дальше у нас есть очень много свободы в том, как именно мы будем сохранять наш файл. Например, можем выбрать другой сепаратор, не тот, который был изначально. Вот давайте для разнообразия теперь укажем запятую. Дальше мы можем решать, хотим ли мы оставить header в нашем файле. Ну давайте оставим. Напишем header=True, и то же самое можно сделать с индексами. В данном случае индекс нам не очень полезен, поэтому давайте записывать его не будем. Напишем, что индекс нам не нужен. Так, запускаем команду. И теперь давайте убедимся, что наш файл выглядит именно так, как мы ожидаем: наш Data Frame через запятую, с заголовком и без индекса. Сделаем это с помощью команды cat. Теперь нужно написать название нашего файла: updated_ dataset.csv. Где-то мы опечатались. Так, ну вот так получше. Видим, что действительно от первой строчки идут header'ы, дальше идет наша таблица, все данные через запятую. Ровно то, что мы хотели. На этом мы заканчиваем наше первое знакомство с Pandas, а на следующем видео мы продолжим говорить о Data Frame'ах. Мы изучим еще несколько полезных функций и научимся работать с индексами. Также мы будем делать выборки из таблиц.

В этом видео мы продолжаем работать с библиотекой Pandas. Мы узнаем еще несколько полезных функций для работы с data frame, а также поговорим об индексации и селекции. Для начала импортируем нашу библиотеку. Далее снова создаем data frame, делаем это с помощью уже знакомой нам функции read_csv. [ЗВУК] [ЗВУК] Итак, наш data frame перед вами. Первое, что хочется сделать — это посмотреть, какого типа наши столбцы. Это делается с помощью dtypes. [ЗВУК] Мы видим, что все столбцы имеют тип object. Если присмотреться повнимательнее к нашему data frame, то можно заметить, что столбец Birth соответствует дате рождения, а в Python есть специальный тип datetime для работы с датами. Если мы сделаем наш столбец типа datetime, то нам будет удобнее с ним работать, потому что мы сможем вызывать специфичные для datetime функции. Это можно сделать с помощью метода apply. Давайте посмотрим, как он работает. Сразу скажу, что метод apply тоже работает не inplace, поэтому воспользуемся уже привычным синтаксисом с присваиванием. Вызываем метод apply. Итак, что мы хотим? Мы хотим применить к нашему столбцу функцию, которая поменяет его тип. Давайте выберем функцию to_datetime, это также функция модуля от Pandas. Так, вызываем нашу функцию. И теперь смотрим, как изменился наш data frame. Так. Сначала можем просто вывести его на печать. Видим, что немножечко изменился формат записи наших дат. А теперь убедимся, что тип также изменился. Снова вызываем dtypes и видим, что, действительно, колонка Birth изменила свой тип — теперь это datetime. Теперь мы сможем с ней работать, как с датой. А следующая полезная функция, которую мы изучим — это функция info. Оно позволяет нам получить мини-сводку по нашему data frame. Мы видим список всех колонок, которые у нас есть, видим, сколько там ненулевых объектов. Вот мы видим, что в колонке Position есть два нулевых значения. Также мы видим, какие типы данных у нас используются и сколько места тратится на хранение нашего data frame. Мы видим, что наш data frame содержит пропущенные значения, это пропуски в столбце Position, не все должности заполнены. Нам не всегда удобно работать с пропущенными значениями в том виде, в котором они есть, и часто мы хотим их на что-то заменить, чем-то их заполнить. Давайте это сделаем в нашем случае. Например, предположим, что откуда-то из наших априорных данных мы знаем, что везде, где позиция пропущена, она соответствует должности «разнорабочий». Давайте так и заполним. Для этого мы можем воспользоваться методом fillna. [ЗВУК] В качестве аргумента передаем то значение, которым мы хотим заполнить наши пропуски. Мы с вами просто пишем строчку «разнорабочий», и сразу говорим, что мы хотим делать это inplace. Так, запускаем. Убираем лишнюю букву a и еще раз запускаем. Так, теперь давайте посмотрим, как выглядит наш data frame после изменений. На экране появился data frame без пропусков, теперь все наши пропуски заполнены значением «разнорабочий». Но на самом деле, в данном случае мы видим, что наши изменения коснулись только одного столбца. Часто нам удобнее вывести его отдельно. Это можно сделать, обратившись к нему по имени через точку. Например, frame.Position. Видим, что нам вывелся только один столбец, причем он вывелся как series, то есть как обычный массив. Если мы хотим вывести его в виде data frame, то есть чтобы было видно саму таблицу, то нужно обратиться к нему несколько иначе. Указываем значения нашего столбца, вернее, его имя, Position, и видим, что теперь он вывелся в привычной для нас форме в виде таблицы. На самом деле, аналогичным образом можно вывести любой набор столбцов. Давайте выведем имя и позицию, Name и Position. И аналогично можно поступать со строчками. Допустим, мы хотим вывести первые несколько строк. Если мы выводим первые строки, то можно воспользоваться командой head. Допустим, первые три строки. Есть и альтернативный способ вывода первых трех строк нашего data frame. Мы можем работать с frame'ом в данном случае, как с простым списком. Давайте просто обратимся по индексу. Сделаем вот так, и также получим наши первые три строки. Аналогично можно вывести последние три строки. Все очень похоже на обычный список. Вот так, все работает. Если же мы хотим сделать что-то более сложное, например, выбрать какой-то список строк и какой-то список столбцов, мы можем воспользоваться командой loc. Она позволяет обращаться к нашему data frame с помощью обращения к названиям наших осей. Давайте продемонстрируем, как это работает. Вызываем loc. Дальше сначала передаем ему список тех строк, которые мы хотим. Название наших строк — это их индекс, поэтому можем просто написать список цифр. Допустим, первая, третья, пятая строка. Дальше говорим, с какими столбцами мы хотим работать. Давайте выведем Name, например, и City. Так, теперь видим, что получилось ровно то, что мы хотели: три строчки, два столбца. Альтернативно можно обращаться к нашим осям не по имени, а по позиции, то есть по номеру нашего столбца и по номеру нашей строки. Это делается с помощью команды iloc. [ЗВУК] В данном случае первый аргумент не изменится, потому что названия оси совпадают с ее позициями, поэтому просто пишем [1, 3, 5], а вот для обращения к колонкам нам придется просто заменить Name и City на их номера. Соответственно, это получается что? У нас получается нулевой и второй номер. Индексация с нуля. Да, получили тот же самый срез нашего массива. Есть еще один способ обратиться к нашему массиву и сделать выборку — это метод ix. Он умеет работать одновременно и с именами, и с позициями. Давайте проверим. Сначала давайте проверим, как он работает с именами. Повторим те же аргументы, которые мы передавали методу loc. Соответственно, результат должен быть таким же. Так, передаем Name и City и запускаем. Видим, что выгрузка не изменилась. А теперь давайте попробуем передать туда номера. [ЗВУК] Все точно так же, поэтому чаще всего разработчики предпочитают использовать сразу ix, потому что он поддерживает и ту, и другую нотацию. Так. На самом деле, мы можем делать не только такие простые выгрузки из нашей таблицы. Мы можем делать более сложные срезы, удовлетворяющие некоторым логическим операциям. Например, мы можем как-нибудь отфильтровать наш dataset. Давайте возьмем вот этот frame и отфильтруем его по дате рождения, например, выберем только тех людей, кто старше 85-го года рождения. Как это можно сделать? Берем наш data frame. Говорим, что нас будет интересовать поле «дата рождения». Указываем его в квадратных скобках. Дальше записываем явно то логическое выражение, которое мы хотим проверить. В данном случае нас интересует ≥, и давайте будем сравнивать с 85-м годом. Так, нам нужно сначала создать наш datetime объект. Помните, мы заранее поменяли тип нашего столбца, чтобы мы могли работать с ним, как с датами? Поэтому теперь, если мы будем сравнивать этот столбец с датой, то мы получим корректный результат сравнения. Вот так, 1-е января 85-го года. Итак, мы видим, что результат соответствует нашему условию: в таблице остались только те сотрудники, даты рождения которых не раньше, чем 1 января 1985 года. Работает это с помощью логических индексов. Чуть подробнее, что это такое, вы узнаете несколько позже, когда будете изучать библиотеку NumPy. Там вы обязательно познакомитесь с этим понятием. Ну а сейчас мы двигаемся дальше, и давайте мы несколько усложним наши условия. Сейчас мы проверяли условия только на один столбец. Давайте проверим сразу несколько. Так как результат применения нашего условия к стоблцу — логический, то есть true или false для каждой строки, то на самом деле мы можем применить некоторую логическую функцию между различными условиями. Например, мы можем проверить условия на дату рождения, еще одно условие на дату рождения или на какой-то другой столбец и посмотреть, скажем, на их пересечение или на их объединение. Любую логическую функцию. Давайте сначала возьмем некоторое условие на дату рождения, даже давайте оставим то же самое, и проверим условие на город. Например, выберем только тех сотрудников, которые не из Москвы. Синтаксически это будет выглядеть следующим образом. Снова берем наш frame и в квадратных скобках записываем условие. Так как условий будет два, давайте сразу подготовим круглые скобки для каждого из условий. И так как мы уже договорились, что мы будем использовать их пересечение, давайте добавим знак логического «и» между ними. Так, теперь первое условие оставляем без изменений. Дата рождения, дата рождения должна быть не раньше, чем 1 января. Так. [ЗВУК] И следующее условие давайте выберем таким: город не равняется Москве. [ЗВУК] Вот так. Судя по предыдущей таблице, мы ожидаем получить только одну строчку. Давайте посмотрим. Да, ровно так и получилось. Это было пересечение условий. А теперь давайте попробуем сделать объединение условий, то есть логическое «или». Синтаксис будет очень похож. Сначала записываем первое условие, давайте снова его оставим. [ЗВУК] [ЗВУК] Дальше наберем знак логического «или» и запишем второе условие. Давайте выберем тех людей, которые из Волгограда. [ЗВУК] Запускаем нашу команду и видим, что у нас появилось два типа людей. Первые — те, у кого город равняется Волгограду, это первый человек, и все остальные — те, у кого дата рождения позже 1-го января 85-го года. На этом мы закончим работу с data frame. Вы уже научились создавать data frame, модифицировать их, применять к ним различные функции, работать с индексами и делать выборки. На самом деле, это только вершина айсберга, но нам пора двигаться дальше, и в следующей видеолекции вы будете изучать библиотеку NumPy.